using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Text;

namespace SlimShader.DX9Shader
{
	public class AsmWriter
	{
		ShaderModel shader;
		ConstantTable constantTable;
		StreamWriter asmWriter;
		int indent = 0;
		public AsmWriter(ShaderModel shader)
		{
			this.shader = shader;
			constantTable = shader.ParseConstantTable();
		}

		void WriteLine()
		{
			asmWriter.WriteLine();
		}

		void WriteLine(string value)
		{
			asmWriter.WriteLine(value);
		}

		void WriteLine(string format, params object[] args)
		{
			asmWriter.WriteLine(format, args);
		}

		static string ApplyModifier(SourceModifier modifier, string value)
		{
			switch (modifier)
			{
				case SourceModifier.None:
					return value;
				case SourceModifier.Negate:
					return $"-{value}";
				case SourceModifier.Bias:
					return $"{value}_bias";
				case SourceModifier.BiasAndNegate:
					return $"-{value}_bias";
				case SourceModifier.Sign:
					return $"{value}_bx2";
				case SourceModifier.SignAndNegate:
					return $"-{value}_bx2";
				case SourceModifier.Complement:
					throw new NotImplementedException();
				case SourceModifier.X2:
					return $"{value}_x2";
				case SourceModifier.X2AndNegate:
					return $"-{value}_x2";
				case SourceModifier.DivideByZ:
					return $"{value}_dz";
				case SourceModifier.DivideByW:
					return $"{value}_dw";
				case SourceModifier.Abs:
					return $"{value}_abs";
				case SourceModifier.AbsAndNegate:
					return $"-{value}_abs";
				case SourceModifier.Not:
					throw new NotImplementedException();
				default:
					throw new NotImplementedException();
			}
		}

		string GetDestinationName(Token instruction)
		{
			var resultModifier = instruction.GetDestinationResultModifier();

			int destIndex = instruction.GetDestinationParamIndex();

			string registerName = instruction.GetParamRegisterName(destIndex);
			const int registerLength = 4;
			string writeMaskName = instruction.GetDestinationWriteMaskName(registerLength, false);
			string destinationName = $"{registerName}{writeMaskName}";
			if (resultModifier != ResultModifier.None)
			{
				//destinationName += "TODO:Modifier!!!";
			}
			return destinationName;
		}

		string GetSourceName(Token instruction, int srcIndex)
		{
			string sourceRegisterName = instruction.GetParamRegisterName(srcIndex);
			sourceRegisterName = ApplyModifier(instruction.GetSourceModifier(srcIndex), sourceRegisterName);
			sourceRegisterName += instruction.GetSourceSwizzleName(srcIndex);
			if (instruction.IsRelativeAddressMode(srcIndex))
			{
				sourceRegisterName += $"[{GetSourceName(instruction, srcIndex + 1)}]";
			}
			return sourceRegisterName;
		}
		public void WriteIndent()
		{
			asmWriter.Write(new string(' ', indent * 4));
		}
		public void Write(Stream stream)
		{
			asmWriter = new StreamWriter(stream);

			WriteHeader();
			indent++;
			string shaderType = (shader.Type == ShaderType.Vertex) ? "vs" : "ps";
			WriteIndent();
			WriteLine("{0}_{1}_{2}", shaderType, shader.MajorVersion, shader.MinorVersion);

			foreach (Token instruction in shader.Instructions)
			{
				WriteInstruction(instruction);
			}
			indent--;
			WriteLine();
			WriteStatistics();
			asmWriter.Flush();
		}
		public void WriteHeader()
		{
			if (constantTable == null) return;
			WriteLine("//");
			WriteLine("// Generated by {0}", constantTable.Creator);
			if (constantTable.ConstantDeclarations.Count == 0) return;
			WriteLine("//");
			WriteLine("// Parameters:");
			WriteLine("//");
			foreach(var declaration in constantTable.ConstantDeclarations)
			{
				string arraySubscript = "";
				if (declaration.Elements > 1)
				{
					arraySubscript = $"[{declaration.Elements}]";
				}
				WriteLine("//   {0} {1}{2};", 
						declaration.GetTypeName(), 
						declaration.Name,
						arraySubscript
						);
			}
			WriteLine("//");
			WriteLine("//");
			WriteLine("// Registers:");
			WriteLine("//");
			var maxNameLength = constantTable.ConstantDeclarations.Max(cd => cd.Name.Length);
			if (maxNameLength < 12) maxNameLength = 12;
			WriteLine("//   Name{0} Reg   Size", new string(' ', maxNameLength - 4));
			WriteLine("//   {0} ----- ----", new string('-', maxNameLength));
			foreach (var declaration in constantTable.ConstantDeclarations
					.OrderBy(cd => (int)cd.RegisterSet * 1000 + cd.RegisterIndex))
			{
				var size = declaration.Rows * declaration.Columns / 4;
				if (size == 0) size = 1;
				size = declaration.RegisterCount;
				WriteLine(string.Format("//   {0} {1,-5} {2,4}", 
					declaration.Name.PadRight(maxNameLength, ' '),
					declaration.GetRegisterName(),
					size));
			}
			WriteLine("//");
			WriteLine("");
		}
		public void WriteStatistics()
		{
			var instructions = shader.Instructions
				.ToArray();
			int instructionCount = 0;
			int arithmeticCount = 0;
			int textureCount = 0;
			foreach(var token in instructions)
			{
				var size = token.GetInstructionSlotCount();
				instructionCount += size;
				var type = token.GetSlotType();
				if (type.HasFlag(Statistics.SlotType.Arithmetic))
				{
					arithmeticCount += size;
				}
				if (type.HasFlag(Statistics.SlotType.Texture))
				{
					textureCount += size;
				}
			}
			if (arithmeticCount != instructionCount)
			{
				asmWriter.Write("// approximately {0} instruction {1} used ({2} texture, {3} arithmetic)",
					instructionCount,
					instructionCount > 1 ? "slots" : "slot",
					textureCount,
					arithmeticCount);
			}
			else
			{
				asmWriter.Write("// approximately {0} instruction {1} used",
					instructionCount,
					instructionCount > 1 ? "slots" : "slot");
			}
		}
		bool ShouldDeclareSemantics(Token instruction, RegisterType registerType)
		{
			if (registerType == RegisterType.MiscType) return false;
			if (registerType == RegisterType.Addr) return false;
			if(shader.Type == ShaderType.Vertex)
			{
				return true;
			}
			if (registerType == RegisterType.Input)
			{
				switch (instruction.GetDeclUsage())
				{
					case DeclUsage.TexCoord:
					case DeclUsage.Color:
						return true;
					default:
						return false;
				}
			}
			return true;
		}
		private string GetInstructionModifier(Token instruction)
		{
			string result = "";
			var modifer = instruction.GetDestinationResultModifier();
			if (modifer.HasFlag(ResultModifier.Saturate))
			{
				result += "_sat";
			}
			if (modifer.HasFlag(ResultModifier.PartialPrecision))
			{
				result += "_pp";
			}
			if (modifer.HasFlag(ResultModifier.Centroid))
			{
				result += "_centroid";
			}
			return result;
		}
		public string SingleToString(byte[] rawBytes)
		{
			if (rawBytes[0] == 0 && rawBytes[1] == 0 && rawBytes[2] == 0 && rawBytes[3] == 128)
				return "-0"; // "Negative" zero
			var floatValue = BitConverter.ToSingle(rawBytes, 0);
			var foo = (floatValue).ToString("G7");
			return foo;
			var test = (floatValue).ToString("F99");
			while(test[test.Length - 1] == '0')
			{
				test = test.Substring(0, test.Length - 1);
			}
			if(test[test.Length - 1] == '.')
			{
				test = test.Substring(0, test.Length - 1);
			}
			return test;
			

			if (Math.Abs(floatValue) > 10000000000000000.0) // TODO: Threshold is guessed
				return DX9DoubleConverter.ToExactString(floatValue);
			return DX9DoubleConverter.ToExactString(floatValue);
			var result = ((double)floatValue).ToString("F6");
			if (!result.StartsWith("-") && floatValue < 0.0f)
				result = "-" + result;
			return result;
		}

		private void WriteInstruction(Token instruction)
		{
			if (instruction.Opcode != Opcode.Comment && instruction.Opcode != Opcode.End)
			{
				WriteIndent();
			}
			switch (instruction.Opcode)
			{
				case Opcode.Abs:
					WriteLine("abs{0} {1}, {2}", 
						GetInstructionModifier(instruction),
						GetDestinationName(instruction), GetSourceName(instruction, 1));
					break;
				case Opcode.Add:
					WriteLine("add{0} {1}, {2}, {3}",
						GetInstructionModifier(instruction), GetDestinationName(instruction),
						GetSourceName(instruction, 1), GetSourceName(instruction, 2));
					break;
				case Opcode.Cmp:
					WriteLine("cmp{0} {1}, {2}, {3}, {4}",
						GetInstructionModifier(instruction), GetDestinationName(instruction),
						GetSourceName(instruction, 1), GetSourceName(instruction, 2), GetSourceName(instruction, 3));
					break;
				case Opcode.Dcl:
					string dclInstruction = "dcl";
					var registerType = instruction.GetParamRegisterType(1);
					if (ShouldDeclareSemantics(instruction, registerType))
					{
						dclInstruction += "_" + instruction.GetDeclSemantic().ToLower();
					}
					WriteLine("{0}{1} {2}", dclInstruction, GetInstructionModifier(instruction), GetDestinationName(instruction));
					break;
				case Opcode.Def:
					{
						string modifier = GetInstructionModifier(instruction);
						string constRegisterName = instruction.GetParamRegisterName(0);
						string constValue0 = SingleToString(instruction.GetParamBytes(1));
						string constValue1 = SingleToString(instruction.GetParamBytes(2));
						string constValue2 = SingleToString(instruction.GetParamBytes(3));
						string constValue3 = SingleToString(instruction.GetParamBytes(4));
						WriteLine("def{0} {1}, {2}, {3}, {4}, {5}", modifier, constRegisterName, constValue0, constValue1, constValue2, constValue3);
					}
					break;
				case Opcode.DefI:
					{
						string constRegisterName = instruction.GetParamRegisterName(0);
						WriteLine("defi{0} {1}, {2}, {3}, {4}, {5}", 
							GetInstructionModifier(instruction), constRegisterName,
							instruction.Data[1], instruction.Data[2], instruction.Data[3], instruction.Data[4]);
					}
					break;
				case Opcode.DP2Add:
					WriteLine("dp2add{0} {1}, {2}, {3}, {4}", 
						GetInstructionModifier(instruction), GetDestinationName(instruction),
						GetSourceName(instruction, 1), GetSourceName(instruction, 2), GetSourceName(instruction, 3));
					break;
				case Opcode.Dp3:
					WriteLine("dp3{0} {1}, {2}, {3}", 
						GetInstructionModifier(instruction), GetDestinationName(instruction),
						GetSourceName(instruction, 1), GetSourceName(instruction, 2));
					break;
				case Opcode.Dp4:
					WriteLine("dp4{0} {1}, {2}, {3}",
						GetInstructionModifier(instruction), GetDestinationName(instruction),
						GetSourceName(instruction, 1), GetSourceName(instruction, 2));
					break;
				case Opcode.Else:
					WriteLine("else");
					break;
				case Opcode.Endif:
					WriteLine("endif");
					break;
				case Opcode.Exp:
					WriteLine("exp{0} {1}, {2}", 
						GetInstructionModifier(instruction), GetDestinationName(instruction),
						GetSourceName(instruction, 1));
					break;
				case Opcode.Frc:
					WriteLine("frc{0} {1}, {2}",
						GetInstructionModifier(instruction), GetDestinationName(instruction), GetSourceName(instruction, 1));
					break;
				case Opcode.If:
					WriteLine("if {0}", GetSourceName(instruction, 0));
					break;
				case Opcode.IfC:
					WriteLine("if_{0} {1}, {2}",
						((IfComparison)instruction.Modifier).ToString().ToLower(),
						GetSourceName(instruction, 0), GetSourceName(instruction, 1));
					break;
				case Opcode.Log:
					WriteLine("log{0} {1}, {2}",
						GetInstructionModifier(instruction), GetDestinationName(instruction),
						GetSourceName(instruction, 1));
					break;
				case Opcode.Lrp:
					WriteLine("lrp{0} {1}, {2}, {3}, {4}",
						GetInstructionModifier(instruction), GetDestinationName(instruction),
						GetSourceName(instruction, 1), GetSourceName(instruction, 2), GetSourceName(instruction, 3));
					break;
				case Opcode.Mad:
					WriteLine("mad{0} {1}, {2}, {3}, {4}",
						GetInstructionModifier(instruction), GetDestinationName(instruction),
						GetSourceName(instruction, 1), GetSourceName(instruction, 2), GetSourceName(instruction, 3));
					break;
				case Opcode.Max:
					WriteLine("max{0} {1}, {2}, {3}",
						GetInstructionModifier(instruction), GetDestinationName(instruction),
						GetSourceName(instruction, 1), GetSourceName(instruction, 2));
					break;
				case Opcode.Min:
					WriteLine("min{0} {1}, {2}, {3}",
						GetInstructionModifier(instruction), GetDestinationName(instruction),
						GetSourceName(instruction, 1), GetSourceName(instruction, 2));
					break;
				case Opcode.Mov:
					WriteLine("mov{0} {1}, {2}",
						GetInstructionModifier(instruction), GetDestinationName(instruction), GetSourceName(instruction, 1));
					break;
				case Opcode.MovA:
					WriteLine("mova{0} {1}, {2}",
						GetInstructionModifier(instruction), GetDestinationName(instruction), GetSourceName(instruction, 1));
					break;
				case Opcode.Mul:
					WriteLine("mul{0} {1}, {2}, {3}",
						GetInstructionModifier(instruction), GetDestinationName(instruction),
						GetSourceName(instruction, 1), GetSourceName(instruction, 2));
					break;
				case Opcode.Nop:
					WriteLine("nop");
					break;
				case Opcode.Nrm:
					WriteLine("nrm{0} {1}, {2}",
						GetInstructionModifier(instruction), GetDestinationName(instruction), GetSourceName(instruction, 1));
					break;
				case Opcode.Pow:
					WriteLine("pow{0} {1}, {2}, {3}", 
						GetInstructionModifier(instruction), GetDestinationName(instruction),
						GetSourceName(instruction, 1), GetSourceName(instruction, 2));
					break;
				case Opcode.Rcp:
					WriteLine("rcp{0} {1}, {2}",
						GetInstructionModifier(instruction),
						GetDestinationName(instruction), GetSourceName(instruction, 1));
					break;
				case Opcode.Rsq:
					WriteLine("rsq{0} {1}, {2}",
						GetInstructionModifier(instruction), GetDestinationName(instruction), GetSourceName(instruction, 1));
					break;
				case Opcode.Sge:
					WriteLine("sge{0} {1}, {2}, {3}",
						GetInstructionModifier(instruction), GetDestinationName(instruction),
						GetSourceName(instruction, 1), GetSourceName(instruction, 2));
					break;
				case Opcode.Slt:
					WriteLine("slt{0} {1}, {2}, {3}",
						GetInstructionModifier(instruction), GetDestinationName(instruction),
						GetSourceName(instruction, 1), GetSourceName(instruction, 2));
					break;
				case Opcode.SinCos:
					if (shader.MajorVersion >= 3)
					{
						WriteLine("sincos {0}, {1}", GetDestinationName(instruction),
							GetSourceName(instruction, 1));
					}
					else
					{
						WriteLine("sincos {0}, {1}, {2}, {3}", GetDestinationName(instruction),
							GetSourceName(instruction, 1), GetSourceName(instruction, 2), GetSourceName(instruction, 3));
					}
					break;
				case Opcode.Sub:
					WriteLine("sub{0} {1}, {2}, {3}",
						GetInstructionModifier(instruction), GetDestinationName(instruction),
						GetSourceName(instruction, 1), GetSourceName(instruction, 2));
					break;
				case Opcode.Tex:
					if ((shader.MajorVersion == 1 && shader.MinorVersion >= 4) || (shader.MajorVersion > 1))
					{
						WriteLine("texld {0}, {1}, {2}", GetDestinationName(instruction),
							GetSourceName(instruction, 1), GetSourceName(instruction, 2));
					}
					else
					{
						WriteLine("tex {0}", GetDestinationName(instruction));
					}
					break;
				case Opcode.TexLDL:
					WriteLine("texldl {0}, {1}, {2}", GetDestinationName(instruction),
						GetSourceName(instruction, 1), GetSourceName(instruction, 2));
					break;
				case Opcode.TexKill:
					WriteLine("texkill {0}", GetDestinationName(instruction));
					break;
				case Opcode.Rep:
					WriteLine("rep {0}",
						GetDestinationName(instruction));
					indent++;
					break;
				case Opcode.EndRep:
					WriteLine("endrep");
					indent--;
					break;
				case Opcode.DSX:
					WriteLine("dsx{0} {1}, {2}",
						GetInstructionModifier(instruction), GetDestinationName(instruction), GetSourceName(instruction, 1));
					break;
				case Opcode.DSY:
					WriteLine("dsy{0} {1}, {2}",
						GetInstructionModifier(instruction), GetDestinationName(instruction), GetSourceName(instruction, 1));
					break;
				case Opcode.TexLDD:
					WriteLine("texldd {0}, {1}", GetDestinationName(instruction), GetSourceName(instruction, 1),
						GetSourceName(instruction, 2), GetSourceName(instruction, 3),
						GetSourceName(instruction, 4));
					break;
				case Opcode.BreakC:
					WriteLine("break_{0} {1} {2}",
						((IfComparison)instruction.Modifier).ToString().ToLower(),
						GetDestinationName(instruction),
						GetSourceName(instruction, 1));
					indent--;
					break;
				case Opcode.Comment:
				case Opcode.End:
					break;
				default:
					WriteLine(instruction.Opcode.ToString());
					//WriteLine("// Warning - Not Implemented");
					throw new NotImplementedException();
			}
		}
	}
}
